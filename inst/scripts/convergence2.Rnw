%\VignetteIndexEntry{vsn - verifying and assessing the performance with simulated data}
%\VignetteDepends{Biobase,vsn}
%\VignetteKeywords{Expression Analysis}
%\VignettePackage{vsn}

\documentclass[11pt]{article}
\usepackage[margin=2.5cm,noheadfoot]{geometry}

%------------------------------------------------------------
% newcommand
%------------------------------------------------------------
\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}


\begin{document}
\SweaveOpts{eps=FALSE}

%------------------------------------------------------------------------
\title{How to assess the accuracy of vsn with simulated data}
%------------------------------------------------------------------------
\author{Wolfgang Huber}
\maketitle
\tableofcontents

The purpose of this vignette is to demonstrate that the software in
\Rpackage{vsn} actually does what it is supposed to do according to the
mathematical theory. And to see \textit{how fast} (or slow, depending on your
point of view) and \textit{how accurately} it does that.

There are two functions \Rfunction{sagmbSimulateData} and
\Rfunction{sagmbAssess} that can be used to generate simulated data and assess
the difference between the 'true' and 'estimated' data calibration and
transformation by \Rpackage{vsn}. This vignette demonstrates some examples. 
Reference~\cite{HuberSAGMB2003} describes in more detail (i) the
simulation model, (ii) the assessment strategy, and (iii) a comprehensive
suite of assessments with respect to the number of features \Robject{n}, the
number of arrays \Robject{d}, the fraction of differentially expressed genes
\Robject{de}, and the fraction of up-regulated genes \Robject{up}.
%
<<setup, results=hide, echo=FALSE>>=
library("vsn")
set.seed(0x1234)
options(error=recover)

dothis = c("n: one stratum", "n: 8 strata", "d", "nrstrata",
           "de, lts.quantile=0.9", "de, lts.quantile=0.5",
           "up, lts.quantile=0.9", "up, lts.quantile=0.5",
           "fraction NA (d=8)", "fraction NA (d=2)",
           "reference")[1:10]

sim = function(..., what, lts.quantile=0.9, nrrep=20) {
  callpar = list(...)
  ll      = listLen(callpar)
  stopifnot(ll[1]>=1, all(ll[-1]==1))
  res  = matrix(1, nrow=nrrep, ncol=ll[1])
  attr(res, "main") = what
  if(what %in% dothis){
    ## default parameters
    simpar = append(callpar, list(n=4096, d=2, de=0, up=0.5, nrstrata=1, miss=0, log2scale=TRUE)) 
    simpar = simpar[!duplicated(names(simpar))]
    for (i in 1:ll[1]) {
      simpar[[1]] = callpar[[1]][i]
      for (r in 1:nrrep) {
        sim = do.call("sagmbSimulateData", simpar)
        ny  = vsn2(sim$y, strata=factor(sim$strata), 
          lts.quantile=lts.quantile, verbose=!TRUE)
        res[r, i] = sagmbAssess(ny$hy, sim)     
        ##
        ## plot(as.vector(sim$hy), as.vector(ny$hy), pch=".", col=col(sim$hy))
        ##
        ## if(res[r,i]>0.045) {
        ##  z=plotLogLik(si$y, factor(si$strata), ny$par, wh=rbind(c(1,1,1),c(1,1,2)), n=31)
        ## }
      } ## for r
    } ## for i
  } ## if
  return(res)
}

myPlot = function(n, res, log="xy") {
  matplot(n, t(res), pch=20, log=log, ylab='r.m.s. error', main=attr(res, "main"), col="#909090", xlab=deparse(substitute(n)))
  lines(n, colMeans(res), col="blue")
}

myPlot2 = function(n, rl) {
  par(mfrow=c(1,2))
  ylim=range(unlist(rl))
  for(i in seq(along=rl)) {
    matplot(n, t(rl[[i]]), pch=20, ylab='r.m.s. error', xlab=deparse(substitute(n)),
            log="y", ylim=ylim, col="#909090", main=attr(rl[[i]], "main"))
    lines(n, colMeans(rl[[i]]), col="blue")
  }
}
@

%--------------------------------------------------
\section{Number of features $n$}
%--------------------------------------------------
Fig.~\ref{fign} shows the estimation error for the transformation (i.\,e.\
the root mean squared difference between true and estimated transformed data)
as a function of the number of features $n$. If \Rfunction{vsn} works correctly,
the estimation error should decrease roughly as $n^{-1/2}$.
%
<<fign1, fig=TRUE, include=FALSE, prefix=FALSE>>=
## with one stratum
n   = 1000*2^seq(-2, 6)
res = sim(n=n, what="n: one stratum")
myPlot(n, res)
@
<<fign2, fig=TRUE, include=FALSE, prefix=FALSE>>=
## with 8 strata
n   = 1000*2^seq(1, 6)
res = sim(n=n, nrstrata=8, what="n: 8 strata")
myPlot(n, res)
@
%
\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{fign1}
\includegraphics[width=0.5\textwidth]{fign2}
\caption{\label{fign}%
Estimation error as a function of the number of features $n$. 
If \Rfunction{vsn} works correctly,
the estimation error should decrease roughly as $n^{-1/2}$.}
\end{center}
\end{figure}

%--------------------------------------------------
\section{Number of samples $d$}\label{sec:d}
%--------------------------------------------------
Fig.~\ref{figds}a shows the estimation error as a function of the number of
samples $d$. Initially, it also decreases slightly with $d$, but eventually
reaches a plateau. This is because the number of parameters that need to be
estimated is proportional to $d$, so the "number of data points per parameter"
is constant in this plot (in contrast to Fig.~\ref{fign}).
%
<<figd, fig=TRUE, include=FALSE, prefix=FALSE>>=
d   = 2^seq(1, 5)
res = sim(d=d, what="d")
myPlot(d, res)
@
%--------------------------------------------------
\section{Number of strata}\label{sec:nrstrata}
%--------------------------------------------------
In Fig.~\ref{figds}b, we see the estimation error as a function of the number of strata. It
should increase, since for each stratum, we need to estimate separate
parameters, and if the overall number of features does not change, more strata
means less and less data per parameters.
%
<<fignrstrata, fig=TRUE, include=FALSE, prefix=FALSE>>=
nrstrata = 2^seq(0, 4)
res = sim(nrstrata=nrstrata, what="nrstrata")
myPlot(nrstrata, res)
@
%
\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{figd}
\includegraphics[width=0.5\textwidth]{fignrstrata}
\caption{\label{figds}%
Estimation error as a function of (a) the number of samples
and (b) the number of strata. See Sections~\ref{sec:d} and \ref{sec:nrstrata}.}
\end{center}
\end{figure}

%-----------------------------------------------------
\section{Differentially expressed genes}\label{sec:de}
%------------------------------------------------------
In the following code, \Robject{de} is the fraction of differentially expressed genes.
We run the simulation both with default settings \Robject{lts.quantile=0.9} and 
the more robust \Robject{lts.quantile=0.5}.
The reason why \Robject{lts.quantile=0.5} is not the default is that the estimator 
is more efficient (more precise with less data) \textit{if} the fraction of 
differentially expressed genes is not that large. See Figure~\ref{figdiff}.
%
<<figdiff, fig=TRUE, include=FALSE, prefix=FALSE, width=11, height=5.5>>=
de  = (0:6)/10
res1 = sim(de=de, what="de, lts.quantile=0.9")
res2 = sim(de=de, lts.quantile=0.5, what="de, lts.quantile=0.5")
myPlot2(de, list(res1, res2))
@
%
\Robject{up} is the fraction of up-regulated genes among the differentially
expressed genes.  The best results are obtained for \Robject{up}$\approx0.5$,
while the estimation goes up the more unbalanced the situation becomes.
%
<<figup, fig=TRUE, include=FALSE, prefix=FALSE>>=
up  = (0:8)/8
res1 = sim(up=up, de=0.2, what="up, lts.quantile=0.9")
res2 = sim(up=up, de=0.2, lts.quantile=0.5, what="up, lts.quantile=0.5")
myPlot2(up, list(res1, res2))
@
%
\begin{figure}[tbp]
\begin{center}
\includegraphics[width=\textwidth]{figdiff}
\caption{\label{figdiff}%
Estimation error as a function of the number of differentially expressed genes,
for two different settings of \Robject{lts.quantile};
see Section~\ref{sec:de}.}
\end{center}
\end{figure}

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=\textwidth]{figup}
\caption{\label{figds}%
Estimation error as a function of the fraction of up-regulated genes. 
for two different settings of \Robject{lts.quantile};
see Section~\ref{sec:de}.}
\end{center}
\end{figure}

%-----------------------------------------------------
\section{Missing values}\label{sec:miss}
%------------------------------------------------------

<<figmiss>>=
miss = seq(0, 0.75, length=7)
res = sim(miss=miss, d=8, what="fraction NA (d=8)")
myPlot(miss, res, log="y")
@ 
%
<<figmiss2>>=
miss = seq(0, 0.1, length=5)
res = sim(miss=miss, d=2, what="fraction NA (d=2)")
myPlot(miss, res, log="y")
@ 

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.5\textwidth]{figmiss1}
\includegraphics[width=0.5\textwidth]{figmiss2}
\caption{\label{figds}%
Estimation error as a function of (a) the fraction of missing data points
and (b) BLA BLA. See Sections~\ref{sec:miss} and \ref{sec:inc}.}
\end{center}
\end{figure}

%-----------------------------------------------------
\section{Incremental normalization}\label{sec:inc}
%------------------------------------------------------
\textbf{TODO}
<<incr>>=
dat = sagmbSimulateData(n=10000, d=12, de=0, nrstrata=2, miss=0.01, log2scale=TRUE)
v = vsn2(dat)
for(j in seq_len(ncol(dat))){
  vj = vsn2(dat[,j], reference=v)
  browser()
}
@ 

%-----------------------------------------------------
\section{Subsampling}\label{sec:sample}
%------------------------------------------------------
\textbf{TODO}
<<sample>>=

@ 

%-----------------------------------------------------
\begin{thebibliography}{10}
%-----------------------------------------------------

\bibitem{HuberSAGMB2003}
W. Huber, A. von Heydebreck, H. {S\"ultmann}, A. Poustka, and M. Vingron.
\newblock Parameter estimation for the calibration and variance stabilization 
of microarray data.
\newblock \textit{Statistical Applications in Genetics and Molecular Biology}, 
Vol. 2: No. 1, Article 3, 2003. 
http://www.bepress.com/sagmb/vol2/iss1/art3

\end{thebibliography}

\end{document}

